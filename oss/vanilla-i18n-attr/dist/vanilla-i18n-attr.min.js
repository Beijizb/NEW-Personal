/*! vanilla-i18n-attr v0.1.0 (manual build copy) */
(function (global) {
  'use strict';

  var DEFAULT_OPTIONS = {
    basePath: './locales',
    storageKey: 'i18n:locale',
    fallbackLocale: ['en'],
    rtlLocales: ['ar', 'arc', 'dv', 'fa', 'ha', 'he', 'ks', 'ku', 'ps', 'ur', 'yi'],
    noThrow: true,
  };

  var state = {
    options: Object.assign({}, DEFAULT_OPTIONS),
    dictionaries: new Map(),
    locale: null,
    initialized: false,
    requestId: 0,
  };

  var textNodes = new Set();
  var attrNodes = new Set();
  var attrCache = new WeakMap();
  var originalTexts = new WeakMap();
  var originalAttrs = new WeakMap();
  var pendingDir = null;

  function isBrowser() {
    return typeof window !== 'undefined' && typeof document !== 'undefined';
  }

  function getFallbackArray() {
    var fallback = state.options.fallbackLocale;
    if (Array.isArray(fallback)) {
      return fallback.filter(Boolean);
    }
    if (typeof fallback === 'string' && fallback.trim()) {
      return [fallback];
    }
    return ['en'];
  }

  function normaliseBasePath(path) {
    if (!path) return './locales';
    return path.endsWith('/') ? path.slice(0, -1) : path;
  }

  function computeLocaleChain(locale) {
    var chain = [];
    var addUnique = function (loc) {
      if (loc && chain.indexOf(loc) === -1) {
        chain.push(loc);
      }
    };
    addUnique(locale);
    if (locale && locale.includes('-')) {
      addUnique(locale.split('-')[0]);
    }
    getFallbackArray().forEach(function (fallback) {
      addUnique(fallback);
      if (fallback && fallback.includes('-')) {
        addUnique(fallback.split('-')[0]);
      }
    });
    addUnique('en');
    return chain;
  }

  function deepGet(dict, keyPath) {
    if (!dict) return undefined;
    var segments = keyPath.split('.');
    var current = dict;
    for (var i = 0; i < segments.length; i += 1) {
      var segment = segments[i];
      if (current && Object.prototype.hasOwnProperty.call(current, segment)) {
        current = current[segment];
      } else {
        return undefined;
      }
    }
    return current;
  }

  function formatValue(value, vars) {
    if (value == null) return value;
    if (!vars || typeof value !== 'string') {
      return value;
    }
    return value.replace(/\{(\w+)\}/g, function (match, name) {
      return Object.prototype.hasOwnProperty.call(vars, name) ? String(vars[name]) : match;
    });
  }

  function defaultFetch(url) {
    if (!isBrowser()) {
      return Promise.reject(new Error('Locale loading requires a custom fetcher outside the browser.'));
    }
    return fetch(url, { credentials: 'same-origin' }).then(function (response) {
      if (!response.ok) {
        var error = new Error('Failed to load locale from ' + url + ' (status ' + response.status + ')');
        error.status = response.status;
        throw error;
      }
      return response.json();
    });
  }

  function persistLocale(locale) {
    if (!isBrowser()) return;
    try {
      window.localStorage.setItem(state.options.storageKey || DEFAULT_OPTIONS.storageKey, locale);
    } catch (error) {
      if (state.options.noThrow === false) {
        throw error;
      }
    }
  }

  function readPersistedLocale() {
    if (!isBrowser()) return null;
    try {
      return window.localStorage.getItem(state.options.storageKey || DEFAULT_OPTIONS.storageKey);
    } catch (error) {
      return null;
    }
  }

  function applyDirection(locale) {
    if (!isBrowser()) return;
    var rtlLocales = state.options.rtlLocales || DEFAULT_OPTIONS.rtlLocales;
    var isRtl = rtlLocales.indexOf(locale) !== -1;
    var apply = function () {
      var doc = document.documentElement;
      if (doc) {
        doc.setAttribute('dir', isRtl ? 'rtl' : 'ltr');
      }
      if (document.body) {
        document.body.dataset.dir = isRtl ? 'rtl' : 'ltr';
      }
    };
    if (document.readyState === 'loading') {
      pendingDir = apply;
    } else {
      apply();
    }
  }

  if (isBrowser()) {
    document.addEventListener('DOMContentLoaded', function () {
      if (typeof pendingDir === 'function') {
        pendingDir();
        pendingDir = null;
      }
    });
  }

  function parseAttrPairs(element) {
    if (!(element instanceof Element)) return [];
    var raw = element.getAttribute('data-i18n-attr') || '';
    var cached = attrCache.get(element);
    if (cached && cached.raw === raw) {
      return cached.pairs;
    }
    var pairs = raw.split(',').map(function (chunk) {
      var parts = chunk.split(':');
      if (parts.length < 2) return null;
      var attr = parts[0].trim();
      var key = parts.slice(1).join(':').trim();
      if (!attr || !key) return null;
      return { attr: attr, key: key };
    }).filter(Boolean);
    attrCache.set(element, { raw: raw, pairs: pairs });
    return pairs;
  }

  function rememberOriginals(element) {
    if (element.dataset.i18n && !originalTexts.has(element)) {
      originalTexts.set(element, element.textContent || '');
    }
    if (element.dataset.i18nAttr) {
      var pairs = parseAttrPairs(element);
      if (!originalAttrs.has(element)) {
        var map = new Map();
        pairs.forEach(function (pair) {
          map.set(pair.attr, element.getAttribute(pair.attr));
        });
        originalAttrs.set(element, map);
      } else {
        var attrMap = originalAttrs.get(element);
        pairs.forEach(function (pair) {
          if (!attrMap.has(pair.attr)) {
            attrMap.set(pair.attr, element.getAttribute(pair.attr));
          }
        });
      }
    }
  }

  function registerElement(element) {
    if (!(element instanceof Element)) return;
    var hadText = textNodes.has(element);
    var hadAttr = attrNodes.has(element);
    if (element.hasAttribute('data-i18n')) {
      textNodes.add(element);
    }
    if (element.hasAttribute('data-i18n-attr')) {
      attrNodes.add(element);
    }
    if ((!hadText && element.hasAttribute('data-i18n')) || (!hadAttr && element.hasAttribute('data-i18n-attr'))) {
      rememberOriginals(element);
    }
  }

  function registerTree(root) {
    if (!isBrowser() || !root) {
      return { newText: [], newAttr: [] };
    }
    var newText = [];
    var newAttr = [];
    var process = function (element) {
      if (!(element instanceof Element)) return;
      var hadText = textNodes.has(element);
      var hadAttr = attrNodes.has(element);
      registerElement(element);
      if (element.hasAttribute('data-i18n') && !hadText) {
        newText.push(element);
      }
      if (element.hasAttribute('data-i18n-attr') && !hadAttr) {
        newAttr.push(element);
      }
    };

    if (root instanceof Document) {
      process(root.documentElement);
      root.querySelectorAll('[data-i18n], [data-i18n-attr]').forEach(process);
    } else if (root instanceof Element || root instanceof DocumentFragment) {
      process(root);
      root.querySelectorAll('[data-i18n], [data-i18n-attr]').forEach(process);
    }

    return { newText: newText, newAttr: newAttr };
  }

  function resolveTranslation(key, vars, localeChain) {
    var chain = localeChain || computeLocaleChain(state.locale);
    for (var i = 0; i < chain.length; i += 1) {
      var locale = chain[i];
      var dict = state.dictionaries.get(locale);
      if (!dict) continue;
      var raw = deepGet(dict, key);
      if (raw !== undefined && raw !== null) {
        return formatValue(raw, vars);
      }
    }
    if (state.options.noThrow === false) {
      throw new Error('Missing i18n key "' + key + '" for locale chain: ' + chain.join(' -> '));
    }
    return undefined;
  }

  function translateText(elements) {
    var targets = elements || Array.from(textNodes);
    targets.forEach(function (element) {
      var key = element.getAttribute('data-i18n');
      if (!key) return;
      try {
        var value = resolveTranslation(key);
        if (value !== undefined) {
          element.textContent = typeof value === 'string' || typeof value === 'number' ? String(value) : String(value);
        } else if (originalTexts.has(element)) {
          element.textContent = originalTexts.get(element) || '';
        }
      } catch (error) {
        if (state.options.noThrow === false) {
          throw error;
        }
      }
    });
  }

  function translateAttributes(elements) {
    var targets = elements || Array.from(attrNodes);
    targets.forEach(function (element) {
      var pairs = parseAttrPairs(element);
      if (!pairs.length) return;
      var originals = originalAttrs.get(element) || new Map();
      pairs.forEach(function (pair) {
        try {
          var value = resolveTranslation(pair.key);
          if (value !== undefined) {
            element.setAttribute(pair.attr, String(value));
          } else if (originals.has(pair.attr)) {
            var original = originals.get(pair.attr);
            if (original == null) {
              element.removeAttribute(pair.attr);
            } else {
              element.setAttribute(pair.attr, original);
            }
          }
        } catch (error) {
          if (state.options.noThrow === false) {
            throw error;
          }
        }
      });
    });
  }

  function translateAll(payload) {
    translateText(payload && payload.newText ? payload.newText : undefined);
    translateAttributes(payload && payload.newAttr ? payload.newAttr : undefined);
  }

  function ensureLocaleData(locale) {
    if (!locale || state.dictionaries.has(locale)) {
      return Promise.resolve(state.dictionaries.get(locale));
    }
    return API.loadLocale(locale);
  }

  var API = {
    loadLocale: function loadLocale(locale, dictionary) {
      if (!locale) {
        return Promise.reject(new Error('Locale name is required to load translations.'));
      }
      if (dictionary) {
        state.dictionaries.set(locale, dictionary);
        return Promise.resolve(dictionary);
      }
      var basePath = normaliseBasePath(state.options.basePath || DEFAULT_OPTIONS.basePath);
      var url = basePath + '/' + locale + '.json';
      var fetcher = state.options.fetcher || defaultFetch;
      return Promise.resolve(fetcher(url)).then(function (data) {
        if (data && typeof data === 'object') {
          state.dictionaries.set(locale, data);
          return data;
        }
        state.dictionaries.set(locale, {});
        return {};
      }).catch(function (error) {
        var status = error && error.status;
        if (status === 404 || state.options.noThrow !== false) {
          state.dictionaries.set(locale, {});
          if (state.options.noThrow !== false && typeof console !== 'undefined' && typeof console.warn === 'function') {
            console.warn('vanilla-i18n-attr: missing locale file for "' + locale + '" at ' + url + '.');
          }
          return {};
        }
        throw error;
      });
    },

    translateDOM: function translateDOM(root) {
      if (!isBrowser()) return;
      var target = root || document;
      var registered = registerTree(target);
      translateAll({ newAttr: registered.newAttr, newText: registered.newText });
    },

    getLocale: function getLocale() {
      return state.locale;
    },

    t: function t(key, vars) {
      if (!key) {
        throw new Error('Translation key is required.');
      }
      var value = resolveTranslation(key, vars);
      if (value === undefined) {
        return key;
      }
      return typeof value === 'string' || typeof value === 'number' ? String(value) : String(value);
    },

    setLocale: function setLocale(locale) {
      if (!locale) {
        return Promise.reject(new Error('Locale name is required to change locale.'));
      }
      var requestId = ++state.requestId;
      if (isBrowser() && !state.initialized) {
        registerTree(document);
        state.initialized = true;
      }
      var chain = computeLocaleChain(locale);
      var loadSequence = chain.reduce(function (promise, loc) {
        return promise.then(function () {
          return ensureLocaleData(loc);
        });
      }, Promise.resolve());

      return loadSequence.then(function () {
        if (requestId !== state.requestId) {
          return state.locale || locale;
        }
        state.locale = locale;
        applyDirection(locale);
        if (isBrowser()) {
          translateAll();
          persistLocale(locale);
        }
        if (typeof state.options.onLocaleChange === 'function') {
          state.options.onLocaleChange(locale);
        }
        return locale;
      });
    },

    initI18n: function initI18n(options) {
      state.options = Object.assign({}, DEFAULT_OPTIONS, options || {});
      state.options.basePath = normaliseBasePath(state.options.basePath || DEFAULT_OPTIONS.basePath);
      if (state.options.fallbackLocale == null) {
        state.options.fallbackLocale = DEFAULT_OPTIONS.fallbackLocale;
      }
      var userLocale = state.options.locale;
      var initialLocale = (function determineInitialLocale() {
        if (userLocale) return userLocale;
        var persisted = readPersistedLocale();
        if (persisted) return persisted;
        if (isBrowser() && window.navigator && window.navigator.language) {
          return window.navigator.language;
        }
        var fallbacks = getFallbackArray();
        if (fallbacks.length) return fallbacks[0];
        return 'en';
      })();
      return API.setLocale(initialLocale);
    },
  };

  if (isBrowser()) {
    registerTree(document);
  }

  var exported = {
    initI18n: API.initI18n,
    setLocale: API.setLocale,
    getLocale: API.getLocale,
    t: API.t,
    loadLocale: API.loadLocale,
    translateDOM: API.translateDOM,
  };

  if (typeof module === 'object' && typeof module.exports !== 'undefined') {
    module.exports = exported;
  }

  global.VanillaI18nAttr = exported;
})(typeof window !== 'undefined' ? window : globalThis);
